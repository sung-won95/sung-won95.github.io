[{"content":"1장 - 깨끗한 코드 나쁜코드는 생산성을 떨어트린다 (개발방향을 산정하지 않은코드는 생산성을 떨어트린다)\nC++ 창시자 나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 없기 때문이다. 의존성을 줄여야 유지보수가 쉬워진다. 깨끗한 코드는 한가지를 제대로 한다. 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 잘 읽히고 설계자의 의도를 바로 알 수 있다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다 코드는 추측이아니라 사실에 기반해야한다. 반드시 필요한 내용만 담아야하며 단호하게 끝내야한다. 이클립스 창시자 깨끗한 코드는 작성자가 아닌 사람도 읽기쉽고 고치기 쉽다. 깨끗한코드는 의미있는 이름이 붙는다. 의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 언어에따라 필요한 모든 정보는 코드로 나올 수 없기 때문에 코드는 문학적으로 표현해야한다. 요점은 인간이 읽기 좋은 코드를 작성하라는 말입니다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로 고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 2. 의미있는 이름 의도가 분명하게 이름을 지어야 합니다.\n변수나 함수 클래스의 이름은 존재이유, 수행기능, 사용방법 을 모두 포함해야합니다.\n냄새나는 코드 int d; // 경과시간 (단위 : 날짜) 클린코드 int timeInDays; int daysSinceCreation; 또한 의미가 없는 메소드를 만들면 다른사람이 이해하기 어렵다.\n복잡한 문장을 사용한게 아니라 의도자체를 파악하기 어렵기 때문이다.\n즉 코드의 맥락과 목적이 명시적으로 들어나지 않는다.\n우리가 지뢰찾기를 만든다고 가정하고 아래 코드들을 읽어보자\n냄새나는코드 public List\u0026lt;int[]\u0026gt; getThem(){ List\u0026lt;int[]\u0026gt; list1 = new ArrayList\u0026lt;int[]\u0026gt;(); for (int[] x: theList) if (x[0] == 4) list1.add(x); return list1; } 단순히 이름만 고쳤을뿐인데!\n theList에 무엇이 들었는가 theList에서 0번째값이 무엇인가 값4는 무슨 의미인가 함수가 반환하는 list1이 무엇인가  위 4가지의 의미를 파악할 수 있게되었다!!!\n클린코드 public List\u0026lt;int[]\u0026gt; getFlaggedCells(Gameboard gameboard){ List\u0026lt;int[]\u0026gt; flaggedCells = new ArrayList\u0026lt;int[]\u0026gt;(); List\u0026lt;int\u0026gt; intList = new ArrayList\u0026lt;int\u0026gt;(); for (int[] cell : gameboard) if (cells[STATUS_VALUE] == FLAGGED) flaggedCells.add(cell); return flaggedCells; } int 배열까지 클래스화 시킨 코드 public List\u0026lt;Cell\u0026gt; getFlaggedCells(){ List\u0026lt;Cell\u0026gt; flaggedCells = new ArrayList\u0026lt;Cell\u0026gt;(); for (Cell cell : gameoard) if (cells[STATUS_VALUE] == FLAGGED) flaggedCells.add(cell); return flaggedCells; } 그릇된 정보도 피해야한다. 그릇된 정보와 단서는 코드의 의미를 흐리기 때문이다\n예를들어 직각삼각형의 빗변(hypotenuse)를 변수화한다고 hp를 쓰면 안된다.\n우리에게 hp는 피통, hp 회사 등 여러가지로 생각 할 수 있기 때문이다.\n더불어서 O (영어 o) 0 (숫자0) l(소문자 L) I(대문자 i) 등도 쓰면 안된다 ex) 0ooOOllIIlI\n발음하기 쉬운 이름을 사용해라\n개발도 커뮤니케이션이다. \u0026ldquo;흠\u0026hellip; 여기 int bcr3cntfsgqueue가 있군요\u0026rdquo; 라고 하는건 비효율이다.\nprivate Date genymdhms; private Date modymdhms; private Date generationTimestamp; private Date modificationTimestamp; 위 코드는 누가봐도 아래 코드가 더 잘 짰다고 할것이다\n검색하기 쉬우면서 일기 쉬운 코드를 작성해라\nfor(int j=0; j\u0026lt;34; j++){ s += (t[j]*4)/5; } 위의 코드와 아래코드는 동일하게 동작한다.\nint realDaysPerIdealDay = 4; const int WORK_DAYS_PER_WEEK = 5; int sum = 0; for(int j=0; j \u0026lt; NUMBER_OF_TASKS; j++){ int realTaskDays = taskEstimate[j] * realDaysPerIdealDay; int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK); sum += realTaskWeeks; } 뭘 하는지도 읽으면서 확실히 와 닿으며 검색하기도 쉽다!\n만약 위에 코드를 검색해 변경하려면 \u0026ldquo;5\u0026quot;를 검색해서 내 코드중 5가 들어간 몇백개의 라인을 봐야하는반면\n아래코드는 WORK_DAYS_PER_WEEK를 검색하면 된다는거다!\n클래스나 객체 이름은 명사나 명사구가 적합하다.\nCustomer, WikiPage, Account 등이 좋은것이며\nManager, Processor, Data는 피하고 동사는 사용하지 않는다\n메서드 이름은 동사나 동사구가 적합하다.\npostPayment, deletePage, save등이 좋은예다\njavabean 표준은 get set is 등을 붙이는거다.\nstring name = employee.getName(); customer.setName(\u0026#34;Mike\u0026#34;); if(paycheck.isPosted())... 의미있는 맥락을 추가해라\n스스로 의미가 분명한 이름이 없지는 않다. 하지만 대다수는 의미가 부족하다.\n그래서 클래스, 함수, 이름에 맥락을 부여해야한다. 이마저도 안된다면 마지막 수단으로 접두어를 붙인다.\nex) firstName, lastName, street, houseNumber, city, state, zipCode\n위 변수를 훑어보면 주소라는 사실을 알 수있다. 하지만 저 중 city 한개만 사용한다면 주소까지 생각하는건 어렵다\nex) addrFirstName, addrLastName, addrCity\n위처럼 앞에 addr을 붙여주면 주소라는 사실을 어디서든 알 수 있다!\nClass Address(){ String firstName; String lastName; ... } 그렇지만 가장 좋은것은 Addr 클래스를 만드는것이다 :)\n아래예제 중 함수 이름은 맥락 일부만 제공하며 알고리즘이 나머지 맥락을 제공한다.\n함수를 끝까지 읽어보고 나서야 number, verb, pluralModifier라는 변수가 통계로 사용된다는 사실을 안다.\nprivate void printGuessStatistics(char candidate, int count){ String number; String verb; String pluralModifier; if(count ==0){ number = \u0026#34;no\u0026#34;; verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } else if (count == 1 ){ number = \u0026#34;1\u0026#34;; verb = \u0026#34;is\u0026#34;; pluralModifier = \u0026#34;\u0026#34;; } else { number = Integer.toString(count); verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } String guessMessage = String.format( \u0026#34;There %s %s %s%s\u0026#34;, verb, number, candidate, plurModifier ); print(guessMessage); 이 함수는 클래스를 만든 후 같은 변수를 쓰는것 만으로 알고리즘도 명확해지고 맥락도 명확해진다\npublic class GuessStatisticsMessage{ private String number; private String verb; private String pluralModifier; public String make(char candidate, int count){ createPluralDependentMessageParts(count); return String.format( \u0026#34;There %s %s %s%s\u0026#34;, verb, number, candidate, plurModifier ); } private createPluralDependentMessageParts(int count){ if(count == 0){ this.thereAreNoLetters(); } else if (count == 1){ this.thereIsOneLetter(); } else{ this.thereAreManyLetter(count); } } private thereAreNoLetters(){ this.number = \u0026#34;no\u0026#34;; this.verb = \u0026#34;are\u0026#34;; this.pluralModifier = \u0026#34;s\u0026#34;; } private thereIsOneLetter(){ this.number = \u0026#34;1\u0026#34;; this.verb = \u0026#34;is\u0026#34;; this.pluralModifier = \u0026#34;\u0026#34;; } private thereAreManyLetter(int count){ this.number = Integer.toString(count); this.verb = \u0026#34;are\u0026#34;; this.pluralModifier = \u0026#34;s\u0026#34;; } } private void printGuessStatistics(char candidate, int count){ GuessStatisticsMessage guessStatisticsMessage = new GuessStatisticsMessage() guessStatisticsMessage.make(candidate, count) 좋은 이름을 선택하려면 설명능력이 뛰어나야하고 문화적인 배경이 같아야한다. 이것이 제일 어렵다.\n네이밍 자체는 그때그때 더 좋은게 생각나면 바꿔야한다.\n다른사람이 짠 코드를 볼때는 리팩터링 도구를 사용해 이름을 개선하라\n단기적인 효과는 물론 장기적인 이익도 보장한다.\n","date":"2022-01-19T10:24:37+09:00","permalink":"https://sung-won95.github.io/p/1%EC%9E%A5-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/","title":"1장 클린코드"},{"content":"함수를 만드는 규칙 1. 작게 만들어라!  작아지면 코드가 단순 명료해지기에 이해하기 쉬워진다 어떻게 작게 만드나? 단순히 짧게 만들면 되는 것인가? → 아래의 내용에서 추가됨.  2. 한가지 기능만 해라  기능의 단위를 통해 작게 만들면 된다. 그렇다면 그 기능의 단위를 어디까지 볼것인가?  추상화 수준으로 구분하면 된다.   추가로 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것으로 판단할 수 있다.  추상화란? 함수의 기능 자체를 단순화 시킨다\n세부적인 기능이 아닌 중복되는 기능을 제거한다\n예를 들어봅시다 핸드폰을 사용하여 다른 사람에게 전화하는 함수. def call_other(by_name : str) 연락처 찾기 ( by_name) 찾은 연락처로 전화하기. 이렇게 두가지 기능으로 나눌 수 있다. 연락처를 찾는 방법은 연락처 리스트에서 by_name과 같은 사람을 찾아야함. 3. 함수 당 추상화 수준은 하나로!  함수가 한가지 기능만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다. 위에서 아래로 코드 읽기 : 내려가기 규칙  코드 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한번에 한단계씩 낮아진다. TO 문단을 읽듯이 프로그램이 읽혀야 한다는 의미.    4. Switch 문 ( if/else도 마찬가지) 저차원 클래스에 숨기고 절대로 반복하지 않는 방법을 사용.\n다형성을 이용한다.\n 다형성 : 클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없으므로, 자식 클래스에서 사용할 수 있는 멤버의 개수가 언제나 부모 클래스와 같거나 많게 됩니다. 따라서 자식 클래스에 부모 클래스를 값으로 넣으면 안된다.  추상 팩토리에 넣어서 파생 클래스의 인스턴스를 생성한다.\n5. 서술적인 이름을 사용하라 함수가 하는 일을 명확하게 설명 가능한 이름을 지정해야한다.\n함수가 작으면 작을수록 서술적인 이름을 고르기 쉬워진다.\n이름이 길어도 괜찮다.\n길고 서술적인 이름은\n 짧고 어려운 이름보다 좋다 길고 서술적인 주석보다 좋다  함수 이름 정하는 방법\n  여러 단어가 쉽게 읽히는 명명법을 사용\n  여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택\n  일관성이 있어야 한다.\n 모듈 내에서 함수 이름은 같은 문구,명사, 동사를 사용함.  include\u0026#34;Setup\u0026#34;And\u0026#34;Teardown\u0026#34;Pages include\u0026#34;Setup\u0026#34;Pages includeSuite\u0026#34;Setup\u0026#34;Page //includeSuite\u0026#34;Teardown\u0026#34;Page 당연히 있을거 등이 좋은 예. 이러면 당연히 include\u0026#34;Teardown\u0026#34;Pages includeSuite\u0026#34;Teardown\u0026#34;Page 이 함수들도 있다고 예측이 가능하기때문에.   6. 함수 인수 이상적인 인수 개수 : 0개 → 1개(단항) → 2개(이항)\n하지만 3개 이상부터는 가능한 피하는 편이 좋다.\n4개는 특별한 이유가 있어도 쓰면 안된다\n인수를 넣게 되면 인수가 없는 코드보다 이해하기 어렵다.\nStringBuffer newPageContent = new StringBuffer(); includeSetupPageInto(new PageContent) --------------------------------------------------------------- includeSetupPage() 1) 함수이름과 인수 사이에 추상화 수준이 다르다. 2) 코드를 읽는 사람이 현 시점에서 별로 중요하지 않은 세부사항 즉, stringBuffer를 알아야한다. 인수를 많이 넣을수록 테스트 관점에서도 어렵다.\n인수가 없는 테스트 케이스와 인수가 4개인 테스트 케이스에 값을 넣고 결과를 확인한다면? 인수가 4개인 테스트 케이스는 훨씬 다양한 경우의 수가 발생된다. 자주 사용하는 단항 인수 ( 총 2가지 )\n 인수에 질문을 던지는 경우   boolean fileExists(\u0026ldquo;MyFile\u0026rdquo;) MyFile이라는 파일의 존재 여부를 물어보는 경우임.  인수를 뭔가로 변환해 결과를 반환하는 경우   InputStream fileOpen(\u0026ldquo;MyFile\u0026rdquo;) string 형의 이름의 파일을 읽어와서 InputStream 형식으로 변환시켜주는 역할 자바에서는 InputStream에서 read_buffer를 통해 지정된 buffer의 크기만큼의 string을 가져올 수 있음  다른 예시 int oneToNumberSum(int number) number을 입력받아 1부터 number까지 더하고 더한 값을 int형으로 반환시켜주는 형식 이 형태는 좋은 형태 이유 : 하나의 입력에 하나의 출력이 있기 때문에. 값을 변환시키지 않고 입력 함수를 그대로 돌려주는 함수라 할지라도 변환 함수 형식을 따르는 편이 좋다. 적어도 변환 형태가 유지되기 때문에. but void oneToNumberSum(int number) number을 입력받아 1부터 number까지 더하고 더한 값을 number 값을 변경하여 반환함. 안 좋은 형태 변환 함수에서 출력 인수를 사용하면 혼란을 일으킬 수 있기때문에. 플래그 인수 추하다.\n함수로 부울 값을 넘기는 관례는 정말로 끔찍하다\n→ 함수가 한꺼번에 여러 가지를 처리한다는 의미이기 때문에.\n→ 플래그가 참이면 이런 기능을 처리하고, 거짓이면 다른 기능을 처리한다는 의미.\n이항 함수 ( 인자가 2개인 함수) writeField(name) vs writeField(outputStream, name) 둘 다 의미가 명백하지만, 인자가 1개인 함수가 인자가 2개인 함수보다 더 읽히기 쉽고 빨리 이해된다. 인자가 2개인 함수는 결국 첫번째 인자 outputStream을 무시해야한다는 사실을 깨닫는다. 하지만 그렇게 무시를 하다보면 결국 큰 문제가 생기게 된다. 이항 함수가 적절한 경우 (좋은 예)\n 포인터  Point p = new Point(0, 0) 두 인수는 1개의 값을 표현하는 두 요소이고, 자연적인 순서도 있다.    하지만 위의 outputStream과 name 간에는 한 값을 표현하지도, 자연적인 순서가 있지도 않다.\n이항함수를 불가피하게 쓸 수도 있지만 가능하다면 단항 함수로 바꿔야한다.\n삼항함수 인자가 3개인 함수는 2개인 함수보다 훨씬 위험하다.\n이항 함수보다 고려해야할 상황들이 더 많기 때문이다.\n함수의 인자 순서나 인자의 무시 등으로 일어나는 상황들.\nCircle makeCircle(double x, double y, double radius)\n→ Circle makeCircle(Point center, double radius)\n이런식으로 3개를 2개로 변경할 때 변수 명도 명확하게 변경할 수 있다.\n최대한 사용하지 않게 해야한다.\n인수 목록 인수의 개수가 가변적인 함수도 마찬가지이다.\n예를들어 가변 인수를 전부 동등하게 취급하면 List형 인수 1개로 취급할 수도 있다.\nString.format(\u0026#34;name = %s, age = %d\u0026#34;,name, age) // 이 함수는 이항 함수이다.  String.format(\u0026#34;name = %s, age = %d\u0026#34;, person1.makeStringFormat()) why? String.format 함수 선언부에 보면 public String format(String format, Object... args) 이런식으로 되어있는데 앞에는 string이고 뒤에는 변수들이다. 변수들에는 다양한 변수들이 여러개 들어갈 수 있지만 동등하게 취급되기에 이항 함수이다. 동사와 키워드 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수.\n단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.\nwrite(name)은 누구나 다 이해 가능\nname이 무엇이든 쓴다는 의미이다.\n더 나은 이름은 writeField(name)이다.\n그러면 name이 필드 명이라는 사실이 드러난다.\n키워드 예제\nassertEquals(expected, actual) : 예측값과 결과값을 비교하여 테스트 결과값을 확인하는 함수.\nexpected라는 변수와 actual이라는 변수의 순서를 항상 외워둬야함\n두개가 바뀐다면 다른 값이 출력되기때문에.\n따라서 키워드를 사용해서 함수 명을 바꿔줄 수 있다.\nassertExpectedEqualsActual(expected, actual) 이렇게 바꾼다면 함수 명만 보고 호출할 시에 인수를 헷갈리지 않고 사용할 수 있다.\n7. 부수효과를 일으키지 마라 부수효과란? → 거짓말을 의미.\n함수에서 한 작업을 하겠다고 이름으로 약속하고선 남몰래 다른 것도 하는거라서.!\n 예상치 못하게 클래스 변수를 수정하거나 함수로 넘어온 인수나 시스템 전역 변수를 수정하는 짓들의 총칭 저자는 교활하고 해로운 거짓말이라고 표현함. 이런 부수효과가 많다면 시간적인 결합이나 순서 종속성을 초래  시간적인 결합 순서 종속성    \u0026lt;시간적인 결합과 순서 종속성에 관한 예제\u0026gt;\n시간적인 결합은 2가지 개념이 존재한다. 동시성과 순서적인 개념. 1) 동시성 : 같은 시간에 일어나도 되는 일. 2) 순서적인 개념 : 항상 A매서드 이후에 B매서드가 실행되어야 한다. 예를 들어서 실제 노트에 적었던 내용들을 노션에 옮겨 적으려고 하는 행동을 설계한다면 1. 실제 노트를 열어서 옮길 내용을 찾는다 2. 컴퓨터를 켜서 노션을 킨다. 3. 옮길 내용을 노션에 작성한다. 이러한 프로그램이 있다면 동시에 진행될 수 있는 작업은 1번과 2번이다. 1,2는 동시성이 충족된다 : 동시에 동작 가능 3번은 항상 1,2가 실행된 후에 실행되어야 한다. : 순서 종속성 \u0026lt;부수효과 예제\u0026gt;\npublic class UserValidator { private Cryptographer cryptographer; public boolean checkPassword(String userName, String password) { User user - UserGateway.findByName(userName); if(user != User.NULL) { String codedPhrase = user.getPhraseEncodeByPassword(); String Pharse = cryptographer.decrypt(codePhrase, password); if(\u0026#34;Valid Password\u0026#34;.equals(phrase)){ Session.initialize(); return true; } } return Fasle; } } 위의 예제는 겉으로는 무난해 보이는 함수이다\nuserName과 password를 확인하는 함수이다\n하지만 이 함수는 부수 효과를 일으킨다.\n부수 효과의 위치는 ? Session.initialize() 호출이다\u0026hellip;!!!!!\n위의 함수는 함수 명이 checkPassword 인데 불구하고 password가 맞으면 세션을 초기화 시키고 true를 반환한다.\n이름만 봐서는 세션을 초기화 시키는 기능은 전혀 생각할 수 없다.\n이런 부수 효과가 시간적인 결합을 초래함.\n즉, checkPassword 함수는 특정 상황(세션이 초기화 되도 괜찮은 상황)에서만 호출이 가능하다.\n의도치 않게 호출한다면 세션 정보가 날라감.\n이러한 시간적인 결합이 필요하다면 반드시 함수 이름에 표기해야함.\ncheckPasswordAndInitializeSession()이라는 이름이 훨씬 좋다.\n→ 근데 한가지 기능만 한다는 규칙을 위반한다\n출력 인수 인수 : 함수의 입력을 의미함.\n인수를 출력으로 사용하면 어색하다.\n\u0026lt;예제\u0026gt;\nappendFooter(s); 이 함수는 s를 무언가에 추가한다는 의미인가? s에 바닥글을 첨부할까? 선언을 봐야 확실해진다. public void appendFooter(StringBuffer report) 이 선언을 본다면? 인수 s가 출력인수라는 사실이 나온다. 이 선언을 보는 행위 자체가 함수를 보고 주춤하는 것과 같은 급으로 취급한다. 인지적으로 거슬린다는 뜻이므로 피해야한다. 거슬리지 않게 바꾸면? 함수에서 상태를 변경하려고 한다면 함수가 속한 객체 상태를 변경하는 방식을 택해야한다. report.appendFooter() 8. 명령과 조회를 분리하라 함수는 1가지 기능만 해야해서\n명령을 수행하거나\n뭔가에 답하거나 둘중 한개만 해야함\n객체 상태를 변경하거나, 아니면 객체 정보를 반환하거나 둘 중 하나다.\n\u0026lt;예제\u0026gt;\npublic boolean set(String attribute, String value); 이 함수는 attribute인 속성을 찾아 값을 value로 설정한 후 성공하면 true를 반환하고 실패하면 false를 반환한다. if (set(\u0026#34;username\u0026#34;, \u0026#34;unclebob\u0026#34;))... 이와 같이 괴상한 코드가 나온다. 위 set 함수는 의미가 모호하다. 이 set이라는 단어가 동사인지 형용사인지 구분하기 어렵다. 이 함수를 구현한 사람은 동사로 구현했지만, if문에 넣고 보면 \u0026#34;username\u0026#34; 속성이 unclebob으로 설정되어 있다면으로 읽히는지? 원래 의도한대로 \u0026#34;username\u0026#34; 속성을 unclebob으로 설정하는데 성공했다면으로 읽히는지? 이럴 때 조회와 명령을 구분해 혼란을 해결하는게 중요하다. if( attributeExists(\u0026#34;username\u0026#34;){ setAttribute(\u0026#34;username\u0026#34;, \u0026#34;unclebob\u0026#34;); } 9. 오류 코드보단 예외를 사용하라. 오류 코드 사용 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.\nwhy? :\n자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다.\nif (deletePage(page) == E_OK)\n이런식으로 사용될때 위반된다.\n따라서 이러한 오류 코드보단 예외를 사용하여 처리하는게 좋다.\n자바에서는 try / catch문이다.\n\u0026lt;오류코드 예제\u0026gt;\nif (deletePage(page) == E_OK) { if( registry.deleteReference(page.name) == E_OK){ if (configKeys.deleteKey(page.name.makeKey() == E_OK){ logger.log(\u0026#34;page deleted\u0026#34;); } else { logger.log(\u0026#34;configKey not deleted\u0026#34;); } } else { logger.log(\u0026#34;deleteReference from registry filed\u0026#34;); } } else{ logger.log(\u0026#34;delete filed\u0026#34;); return E_ERROR; } \u0026lt;try catch로 변경\u0026gt;\ntry { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name,makeKey()); } catch (Exception e){ logger.log(e.getMessage()); } 이런 try / catch문은 원래 추하다고 표현한다.\n그래서 try구문자체를 하나의 함수로 묶어서 표현하는 방식이 제일 좋다.\npublic void delete(Page page){ try { deletePageAndAllReferences(page); } catch (Exception e){ logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name,makeKey()); } private void logError(Exception e){ logger.log(e.getMessage()); } 오류 처리도 한가지 작업이다!!!!!\n의존성 자석 : 1개의 클래스가 변한다면 그 클래스를 사용하는 다른 소스들에서도 컴파일이 진행되어야 하는 개념.\n오류 코드를 반환한다는 말은 클래스든 열거형 변수든 어디선가 오류코드를 정의한다는 뜻이다.\n오류 코드를 변환한다면?? 오류코드를 사용하는 모든 클래스를 전부 다시 컴파일 하고 재배치가 필요하다.\n그래서 새로운 오류코드를 만들어내기 보단 기존에 사용하던 오류코드를 쓰는경우가 많아지고 그러면 명확한 오류코드 자체의 존재 이유가 흐려질 수 있다\nException을 사용하자!\n10. 구조적 프로그래밍 에츠허르 데이크스트라의 구조적 프로그래밍 원칙을 따른다.\n모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야한다.\n루프 안에서 continue나 break문을 사용해서는 안되며 goto는 절대 금지한다.\n저자는 목표와 규율은 공감하지만 우리가 원하는 것 처럼 함수가 작다면 이익이 없다.\n12. 함수를 어떻게 짜죠? 처음에는 길고 복잡하게 짤수도 있지만 그런 서투른 코드들을 모두 단위 테스트 한 후 코들를 다듬고 함수를 만들고 이름을 바꾸고 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 이런 와중에도 항상 단위 테스트는 성공해야한다.\n처음부터 완벽하게 짜려고 하지말고 일단 짜놓고 리펙터링 하는 방향으로 발전해 나가는게 좋을 것 같다.\n결론 : 함수의 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수를 만들자. 함수가 분명하고 정확한 언어로 깔끔하게 맞아떨어져야 전체 이야기를 풀어나가기가 쉬워진다! ","date":"2022-01-19T09:24:37+09:00","permalink":"https://sung-won95.github.io/p/2%EC%9E%A5-%ED%95%A8%EC%88%98/","title":"2장 함수"},{"content":"주석의 개념  코드로 직접 실행되지 않지만 코드를 설명하는 문장이나 글  저자가 바라보는 주석이란? 잘달린 주석은 그 어떤 정보보다 유용하다\n나쁜 주석은 코드를 이해하기 어렵게 만든다.\n오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다.\n저자의 표현으로는 사실상 주석은 기껏해야 필요악이라고 한다.\n코드로 의도를 표현하지 못해 실패를 만회하기 위해 주석을 사용한다.\n코드는 변화하고 진화한다.\n하지만 주석은 그 코드를 언제나 따라가진 않는다.\n그렇게 주석이 코드에서 분리되어 점점 더 부정확한 고아로 변하는 사례가 흔하다고 한다.\n프로그래머들이 주석을 엄격하게 관리해야하고 복구성과 관련성, 정확성이 언제나 높아야한다고 주장하는 사람도 있지만 그 노력을 코드를 깔끔하게 하는데 사용해서 주석이 필요 없는 코드를 짜는게 더 낫다고 한다.\n주석은 나쁜 코드를 보완하지못한다. 코드에 주석을 추가하는 일반적인 이유는 코드의 품질이 나쁘기 때문이다.\n코드의 품질이 나쁘다는 얘기는 복잡하고 어수선한 코드이다.\n주석을 달아야겠다가 아니라 코드를 정리해야겠다로 생각을 바꿔야한다.\n코드로 의도를 표현하라 // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if ((employee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; employee.age \u0026gt; 65) vs if (employee.isEligibleForFullBenefits()) # Eligible : 가질수 있는 # FullBenefits : 완전한 혜택? 좋은 주석  법적인 주석  각 소스파일 첫머리에 주석으로 들어가는 저작권 정보와 소유권 정보의 주석을 의미.   정보를 제공하는 주석  기본적인 정보를 주석으로 제공하면 편리하다.    // 테스트 중인 Responder 인스턴스를 반환한다. protected abstract Responder responderInstance(); # 때때로 위와 같은 주석이 유용할지라도 가능하다면 함수 이름에 정보를 담는 편이 더 좋음.  결론 : 코드를 깔끔하게 한다면 정보를 제공하는 주석은 필요 없을 가능성이 높다. 하지만 때에 따라 특수한 경우가 있기 때문에 때때로 필요할 수도 있다.    의도를 설명하는 주석\n 함수의 기능을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명하는 주석. 코드 작성자의 의도가 분명하게 드러나기 때문에 간혹 필요한 경우가 생길 수 있다.    의미를 명료하게 밝히는 주석\n 인수나 반환값의 의미를 읽기 좋게 표현하는 주석. 일반적으로는 인수나 반환값 자체를 명확하게 만들면 좋겠지만 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝혀주는 것이 좋다. 잘못된 주석이나 검증되지 않은 주석을 검증하기란 쉽지 않기 때문에 주석은 위험하다.    결과를 경고하는 주석\n 테스트 케이스에서 특정 테스트 케이스를 꺼야하는 이유를 설명하는 주석  //여유 시간이 충분하지 않다면 실행하지 마십시오.      TO DO 주석\n 앞으로의 할일을 //TODO 주석으로 남겨두면 편하다. 필요하지만 당장 구현하기 어려운 업무를 기술함 하지만 어떤 용도든 시스템에 나쁜 코드를 남겨놓는 핑계가 되어서는 안된다. TO DO 주석을 주기적으로 점검해 없애도 괜찮은 주석을 없애면서 관리해야한다.    중요성을 강조하는 주석\n 사소하게 넘어갈 부분의 중요성을 강조하기 위해서도 주석을 사용함.    String listItemContent = match.group(3).trim(); // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다. // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다. 나쁜 주석 대다수의 주석이 이 범주에 속함 따라서 큰 특징이 아닌 자잘한 특징은 사소하게 집고 넘어감.\n 주절거리는 주석  어쩔 수 없이 비워두기 뭐해서 작성한 주석. 기왕 작성할 주석이라면 충분한 시간을 들여 최고의 주석을 달도록 노력하자.!!   같은 이야기를 반복하는 주석.  # 간략하게 적음 // 이 컴포넌트의 프로세서 지연값 protected int backgroundProcessorDelay = -1; // 이 컴포넌트를 지원하기 위한 생명주기 이벤트 protected LifecycleSupport lifecycle = new LifecycleSupport(this);  오해의 여지가 있는 주석  주석에 담긴 살짝 잘못된 정보로 인해 다른 프로그래머들이 삽질할 수도 있다.!!   의무적으로 다는 주석 *(1),(2)과 비슷한 내용 이력을 기록하는 주석  현재는 소스 코드 관리 시스템 예를 들어 git의 커밋 내용을 통해 관리 할 수 있는데 굳이 주석으로 달지 않아도 된다!!!!!!!! 없는 예전이나 이렇게 했다\u0026hellip;!!   있으나 마나 한 주석 * (2)번과 비슷한 내용  코드만 봐도 당연히 아는 내용들을 설명한 주석   무서운 잡음  // The name private String name; // The version private String version; // The name private String licenceName; // The version private String info;  함수나 변수로 표현할 수 있다면 주석을 달지 마라  // 전역 목록 \u0026lt;smodule\u0026gt;에 속하는 모듈이 우리가 속한 하위 시스템에 의존하는가? if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) # 아래와 같이 짜면 의존성에 관하여 굳이 주석을 달 필요가 없다. ArrayList moudleDependees = smodul.getDependSubsystems(); String ourSubSystem = subSysMod.getSubSystem(); if (moduleDependees.contains(ourSubSystem))  위치를 표시하는 주석  // Actions ///////////////////////////////// 모든 곳에 이런식으로 배너가 달려있는 경우 가독성을 낮추기 때문에 제거시키자! 어쩌다 한번씩 사용하는 배너는 눈에 띄기 때문에 아주 드물게 사용하는 것이 좋다.   닫는 괄호에 다는 주석  함수의 내용이 길면 길수록 필요한 주석. 하지만 우리는 작고 캡슐화된 함수를 사용하기 때문에 이 주석은 잡음일 뿐이다!!    if(i == 1) { { //....... //....... //....... //....... //....... } //for문 }//if문  공로를 돌리거나 저자를 표시하는 주석  이것두 소스 코드 관리 시스템에서 잘 관리 되니 필요 없음.   주석으로 처리한 코드  절대 주석으로 처리한 코드는 만들지 말자. 대안으로는 해당 코드에 대한 새로운 소스 파일이나 클래스를 테스트용으로 만들어 놓는 것.   HTML 주석 전역 정보  코드의 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 말자    public void setFitnessePort(int fitnessePort) { this.fitnessePort = fitnessePort; }  너무 많은 정보  해당 기술의 역사나 관련 없는 정보를 장황하게 늘어놓는 주석   모호한 관계  주석과 주석이 설명하는 코드의 관계는 명확해야한다.    // 모든 픽셀을 담을 만큼 충분한 배열로 시작한다 ( 여기에 필터 바이트를 더한다 ) // 그리고 헤더 정보를 위해 200바이트를 더한다. this.pngBytes = new byte[((this.width + 1) * this.height * 3 + header]; # 여기서 필터 바이트가 무엇인지 명확히 알 수 없기 때문에 위의 주석은 필요없다.   주석 자체가 코드에 대한 설명인데 주석에 대한 설명을 다시 요구해야하는 상황이 발생됨.   함수 헤더  결론 주석은 쓸데없다. 주석을 달 시간에 코드를 더 간결하고 명확하게 작성해야한다. 만약 어쩔 수 없이 주석을 달려면 코드에 대한 고민을 완료한 후에 달 주석 또한 최대한 고민을 하면서 작성해야만 한다. ","date":"2022-01-19T09:24:37+09:00","permalink":"https://sung-won95.github.io/p/3%EC%9E%A5-%EC%A3%BC%EC%84%9D/","title":"3장 주석"},{"content":"안녕하세요 오늘은 사업계획서를 공유해보려고 합니다. 이 글은 작년 10월 모 창업 경진대회에 제출한 문서를 거의 그대로 옮겼습니다. 해당 대회에서 본선에는 들었지만 발표평가에서 떨어진 문서입니다. 사업계획서를 쓰시는 분들께 도움이 되었으면 합니다. 더불어서 피드백은 언제나 환영입니다!\n1-1. 제품의 차별성 실시간성  1분단위의 실시간 모니터링을 통해 누구보다 빠른 정보전달 가능 기존 어플리케이션들의 서비스 제공 시간폭은 유료 기준 30분 - 1시간 소요  능동적 정보제공  굳이 찾아보지 않아도 알아서 방대한 양의 정보를 정리하여 제공해줌 바쁜 현대인들에게 스스로 시의성 있는 정보와 트렌드를 전달함  제목 기반 키워드 제공  자동 요약 시스템을 통해 부담 없이 손쉽게 트렌드 파악 가능 기사 전체가 아닌 이미 요약되어 있는 제목만을 크롤링 함으로써 더 빠르고 적은 데이터로 서비스 구축 가능  접근성  별도의 앱 설치 없이 카카오톡 챗봇을 이용하여 누구나 쉽게 사용 가능  안드로이드\u0026amp;IOS 이용자 모두 이용가능   앱 알람이 아닌 다수가 사용하는 카카오톡 메시지 알람으로 다른 앱 이용보다 번거로움이 적음  확장성   내용을 집약하여 제목을 작성하는 다른 데이터에 동일한 메커니즘 적용 가능\nex) 논문, 사설, 영화 댓글 ···\n논문 \u0026gt; 특허 \u0026gt; 기사 순으로 트렌드가 정해져 미래 트랜드 예측 가능 기술\n  해외 기사, 자료들도 동일한 방식으로 크롤링\u0026amp;번역 후 제공 가능\n   1-2. 개발 동기 및 필요성 개발동기  앞서 발생한 사건들을 몰라 대화가 원활히 이뤄지지 못하는 문제가 발생하며 잘못된 정보를 가지고 말하여 정보의 왜곡 가능성이 있음 기존에도 \u0026lsquo;유튜브 오늘의 소식 요약\u0026rsquo;, \u0026lsquo;10분 뉴스 추천앱\u0026rsquo; 같은 기능이 있지만, 이동이 많아 집중이 어려운 출퇴근 시간이나, 과제 혹은 업무 도중에 빠르게 정보를 얻을 수 있는 매체가 부족함 정보의 속도가 지속적으로 빨라지고 있기에 그에 맞는 능동적 정보를 제공받을 수 있는 매체가 필요함 흥미도가 떨어지는 기사들, 이해하기 어려운 내용의 기사들 처음 뉴스, 기사를 접하려 하는 젊은이들에게 접근성이 떨어짐  필요성   뉴스가 거창하고 어렵다고 생각하는 이용자들에게 접근하기 쉬운 이미지를 심어줄 필요가 있음\n  트렌드에 민감한 젋은 세대들에게 필요한 정보를 빠르게 접할 수 있게 하여 대응력을 갖추도록 함\n idea/newsBot/Untitled.png \n  10-20 대는 뉴스, 기사 확인 보다는 동영상 시청, SNS 이용률이 높아 디지털 텍스트(인터넷 뉴스, 기사 등등) 의 이용 시간 지속적 감소\n idea/newsBot/Untitled1.png \n  감소하는 디지털 텍스트 컨텐츠 이용시간의 변화에 맞게 짧고 간단하게 소식을 파악할 수 있는 장치가 필요\n  소식에 민감한 회사, 개인사업자, 주식투자자, 스포츠 애호가에게 더욱 빠른 정보 제공이 가능해짐\n   2-1. 개발방안 (시제품 제작 추진일정 등)  idea/newsBot/Untitled2.png \n사용 기술 Crawling  python Scrapy NoSQL  KeyWord 추출  TextRank  ChatBot Server  Flask kakao i open builder  Infra  Cloud Docker   idea/newsBot/Untitled3.png \n 3-1. 자금 소요 및 조달 계획 자금 소요   Server (AWS)\n idea/newsBot/Untitled4.png \n idea/newsBot/Untitled5.png \n  조달계획   투자\n스타트업 투자 (카카오벤처스, KB인베스트먼트, DSC인베스트먼트, 베이스인베스트먼트, 슈미 etc\u0026hellip;)\n  구독 서비스 이익 창출\n  APP 개발 시 APP 내 광고 수익\n  3-2. 시장 분석 및 성과 창출 전략 시장분석 뉴스 시장 NEEDS  기존에 AI, 빅데이터를 접목하지 않은 서비스가 1년안에 40만 사용자를 모음   idea/newsBot/Untitled6.png \n네이버 뉴스 언론사 구독자수·구독건수 2000만 달성   idea/newsBot/Untitled7.png \n구독 시장 NEEDS  구독 시장은 국내는 물론 해외에서도 지속적으로 성장중   idea/newsBot/Untitled8.png \n idea/newsBot/Untitled9.png \n\u0026lsquo;구독경제\u0026rsquo;or\u0026rsquo;구독 경제\u0026rsquo;를 이용한 국내 기사수 추이  idea/newsBot/amCharts.png \n지역 신문사를 제외한 국내 신문사 4개년 구독 경제 기사수\n결론  구독 경제, 구독 서비스에 대한 대중의 이해도, 관심도도 높아지고 있음 현재 이용 가능한 뉴스 컨텐츠를 사용하는 이용자도 적지않음 디지털 텍스트 컨텐츠 이용 비율이 적은 10-20대 젊은 세대를 고객으로 유입 시 더 큰 시장 형성 가능  성과창출 전략 구독 서비스   1년안에 카카오톡 친구추가 50만, APP스토어(IOS)\u0026amp;PLAY스토어(ANDROID) 다운로드 10만 이상이 목표\n  다운로드 사용자 중 10% 구독 서비스 유치 목표\n구독자 이용 가능 컨텐츠  광고제거 맞춤 키워드 추가 제공 검색어 비율 설정가능 축적된 데이터 접근 가능 ex) 연령별 관심사, 키워드 채택 비율, 증가율 등  구독경제관련 뉴스\n온라인 구독 서비스 이용 행태 분석\n   출처 박성원 : parksw1992@naver.com\n이재상 : imjsl22@gmail.com\n","date":"2021-01-04T08:58:32+09:00","permalink":"https://sung-won95.github.io/p/%EB%89%B4%EC%8A%A4-%EA%B8%B0%EC%82%AC-%ED%81%AC%EB%A1%A4%EB%A7%81%EC%9D%84-%ED%86%B5%ED%95%9C-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%B6%94%EC%B6%9C-%EB%B0%8F-%EC%8B%A4%EC%8B%9C%EA%B0%84-%ED%8A%B8%EB%A0%8C%EB%93%9C-%EC%A0%9C%EA%B3%B5-%EC%84%9C%EB%B9%84%EC%8A%A4-trendak/","title":"뉴스 기사 크롤링을 통한 키워드 추출 및 실시간 트렌드 제공 서비스 [Trendak]"},{"content":"프롤로그 안녕하세요 오늘은 OpenCV를 사용하여 CCTV video stream(RTSP)에 YOLO를 돌린 프로젝트 후기를 남겨보려고 합니다. 이 프로젝트는 실시간으로 object detecting 하는 것을 최우선 목표로 진행했습니다. 2K CCTV에서 RTSP 서버를 열어주고 딥러닝(YOLO v4)을 통해 object detecting을 진행 한 뒤 모니터링 서버에서 보여줄때까지 지연시간이 2초 이하로 진행해야 했습니다.\n환경 \u0026amp; 목표 w\n CCTV : 2K RTSP Stream, 16EA Network : 10G GPU : Tesla T4, 8EA AI Model : YOLO v4, 5개 object 구분 목표 : 모니터링 서버에서 2초 이내 detecting object 확인  설계도 RTSP → YOLO v4(분석) | Tesla T4 이용 → View\np.s. YOLO v4(학습 class 5개, 총 용량 268M)모델 2개를 Tesla T4 16GB를 사용해 인퍼런스를 진행하면 10FPS 방어가 가능했습니다.\n /tech/rtsp-opencv-yolov4/Untitled.png \nDocker Setting TensorFlow GPU버전을 사용해야 하기에 tensorflow 공식 이미지중 gpu 태그가 붙은 이미지를 사용했습니다. 또한 docker 내부에서 OpenCV도 사용해야 했기에 ffmpeg을 설치해줬습니다.\ndocker-compose에서 GPU세팅 및 OpenCV 사용 세팅은 (여기)를 참고해 주세요\nDockerfile FROMtensorflow/tensorflow:2.3.0-gpuRUN apt-get updateRUN apt-get install ffmpeg libsm6 libxext6 -yWORKDIR/srcENV PYTHONUNBUFFERED=0 COPY python/requirements.txt ./RUN pip3 install --no-cache-dir -r requirements.txt COPY . /modulerequirements.txt amqp==5.0.1 billiard==3.6.3.0 celery==5.0.0 click==7.1.2 click-didyoumean==0.0.3 click-repl==0.1.6 kombu==5.0.2 prompt-toolkit==3.0.7 pytz==2020.1 vine==5.0.0 wcwidth==0.2.5 opencv-python lxml tqdm absl-py matplotlib easydict pillow docker-compose version:\u0026#39;3.1\u0026#39;services:AirForcePython1:image:tensor_aideploy:resources:limits:cpus:\u0026#39;1\u0026#39;build:context:.dockerfile:python/Dockerfilevolumes:- ../src:/srcenvironment:- VideoPath=rtsp://admin:qazwsx123!@192.168.0.1:554/RTSPSTREAM- CameraId=camera1- DestIp=192.168.0.1- DISPLAY=unix$DISPLAY- NVIDIA_VISIBLE_DEVICES=0- model=yolov4_airforcecommand:python detectvideo.pystdin_open:truetty:true삽질의 기록 GPU를 어떻게 나누지\u0026hellip;. 처음 시작하면서 부터 난관에 봉착했습니다. 일단 TensorFlow를 실행해서 YOLO를 돌린것까진 좋았는데\u0026hellip; 프레임당 100ms 이하로 나오는것도 좋았는데 YOLO를 실행하기만 하면 GPU RAM을 모두 다 차지해버립니다. OTL\u0026hellip; 열심히 구글링 해본 결과 config.gpu_options.allow_growth 옵션을 끄지 않으면 TensorFlow가 남은 GPU RAM을 모두 선점해버리는 현상이 있었습니다. 해결 방법으로는 옵션을 False로 바꾸고 초기 RAM을 얼만큼 차지할지 config.gpu_options.per_process_gpu_memory_fraction 옵션에 넣어주면 됩니다!!! 저는 테스트 결과 stream 3개까지도 아슬아슬하게 10 FPS 방어가 됐는데 GPU가 모자라는게 아니니 GPU 1개당 2개 Stream을 할당해줬습니다.\np.s. 각 GPU에 할당하는건 docker-compose 에서 세팅해줬습니다. NVIDIA_VISIBLE_DEVICES 옵션을 잘 세팅하시면 됩니다 ㅎㅅㅎ\nconfig = ConfigProto() config.gpu_options.allow_growth = False config.gpu_options.per_process_gpu_memory_fraction = 0.4 session = InteractiveSession(config=config) Docker가 이유없이 계속 죽는다\u0026hellip;. try catch로 감싸진게 전혀 없는데 log를 아무리 뒤져도 에러코드가 나오지 않고 죽는 현상이 있었습니다. 정말 docker stop 명령어를 쓴 듯 갑자기 docker가 죽어버렸습니다. 이것도 반나절동안 삽질한 결과 OOM(Out Of Memory)라는 결론을 얻었습니다. RTSP Stream에서 가지고 오는 속도에 비해 object detecting 속도가 느려 메모리에 계속 쌓였던게 원인이였습니다. 이 문제를 해결하기 위해 아래처럼 queue를 사용했습니다. queue size를 3으로 해놓으면 버퍼가 체감이 되었으며 그렇다고 사이즈를 1로 해놓으면 프레임 대기시간이 생기는건지 2보다 느린 관계로 queue size는 2로 설정했습니다\nimport queue q = queue.Queue(2) def Receive(): video_path = os.environ[\u0026#34;VideoPath\u0026#34;] vid = cv2.VideoCapture(video_path) while True: return_value, frame = vid.read() if return_value: q.put(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)) def main(_argv): p1 = threading.Thread(target=Receive) p1.start() while True: try: if q.empty() != True: frame = q.get() # next Code RTSP Stream 재부팅시 자동 연결이 안된다\u0026hellip;. 위와 비슷하지만 docker가 죽진 않았으나 더이상 detecting log가 쌓이지 않는 현상이 있었습니다. 바로 RTSP Stream이 죽어도 receive 함수가 죽지 않았던 것입니다. 단순하게 생각해서 RTSP Stream이 재부팅 되어도 URL이 바뀌지도 않고 기존에 Stream을 계속 read하려고 하면 재부팅 된 뒤 read가 될 줄 알았던 제 어리석은 생각때문이였습니다. vid.read()에서 왜 true, false를 반환하겠니\u0026hellip;\u0026hellip; 여튼 그래서 vid.read가 false를 반환할 때 제 쓰레드를 죽인 뒤 다시 쓰레드를 생성해 새로운 stream을 받아오는걸로 코딩을 했습니다. 쓰레드를 생성할 때 setDaemon(True) 설정 안하면 thread가 정상적으로 죽지 않아서 ram 누수가 발생합니다. 그러니 꼭 setDaemon(True) 설정을 해주시고 맨위에 객체 만들었다고 새로운 객체를 만들지 않고 다시 start 함수만 사용하면 에러가 발생합니다. 어차피 기존 쓰레드는 반납되었으니 새로운 쓰레드를 만들어 사용하는게 좋습니다.\ndef Receive(): print(\u0026#34;start Reveive\u0026#34;) video_path = os.environ[\u0026#34;VideoPath\u0026#34;] print(\u0026#34;Video from: \u0026#34;, video_path ) vid = cv2.VideoCapture(video_path) while True: return_value, frame = vid.read() if return_value: q.put(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)) else: break def main(_argv): p1 = threading.Thread(target=Receive) p1.setDaemon(True) p1.start() while True: if q.empty() != True: frame = q.get() # next Code elif not p1.isAlive(): time.sleep(5) p1 = threading.Thread(target=Receive) p1.setDaemon(True) p1.start() 이렇게 RTSP Stream으로부터 원하는 만큼의 GPU를 사용해 딥러닝을 돌려 확인하는 것 까지 내용을 마쳤습니다. 추후에 이슈사항이 있으면 이 페이지에 추가하겠습니다.\n모든 서버에서 실시간성이 보장되지 않는다. 2020-12-28 여러개의 서버에서 동일한 실시간성이 보장되어야 하는 프로젝트였으나 사양이 더 좋은 서버에서 실시간성이 보장 안되는 이슈가 있었습니다. 이 이슈는 아래 pipe를 생성해서 사용하는것으로 해결했습니다.\n제 생각이지만 cv2.videoCapture를 사용하면 ffmpeg에 버퍼를 먼저 채운 뒤 프레임을 읽어와 제공을 해주는 것 같습니다. 또한 cv2 자체에서도 특정 조건을 만족했을 때 딜레이가 발생하는데 정확한 원인을 모르겠습니다. 혹시 아시는분이 계시다면 댓글 남겨주세요\nimport cv2 import subprocess as sp import numpy command = [\u0026#39;ffmpeg\u0026#39;, \u0026#39;-i\u0026#39;, \u0026#39;rtsp://78.10.34.92/axis-media/media.amp\u0026#39;, \u0026#39;-f\u0026#39;, \u0026#39;image2pipe\u0026#39;, \u0026#39;-pix_fmt\u0026#39;, \u0026#39;bgr24\u0026#39;, \u0026#39;-vcodec\u0026#39;, \u0026#39;rawvideo\u0026#39;, \u0026#39;-\u0026#39;] pipe = sp.Popen(command, stdout=sp.PIPE, bufsize=1280 * 800 * 3) while pipe.poll() is None: if cv2.waitKey(1) \u0026amp; 0xFF == ord(\u0026#39;q\u0026#39;): break raw_image = pipe.stdout.read(1280 * 800 * 3) image1 = numpy.frombuffer(raw_image, dtype=\u0026#39;uint8\u0026#39;) image2 = image1.reshape((800, 1280, 3)) cv2.imshow(\u0026#39;Video\u0026#39;, image2) pipe.stdout.flush() pipe.terminate() cv2.destroyAllWindows() 궁금한점이나 피드백은 환영합니다. 감사합니다.\n","date":"2020-11-24T14:02:42+09:00","image":"https://sung-won95.github.io/tech/rtsp-opencv-yolov4/Untitled.png","permalink":"https://sung-won95.github.io/p/opencv%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-yolov4%EB%A1%9C-cctv-%EC%98%81%EC%83%81-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0/","title":"Opencv를 이용하여 YOLOv4로 CCTV 영상 분석하기"},{"content":"master 서버와 slave 서버에 각각 설정하는 방법이 다릅니다\nMASTER 설정   user 생성\n# psql을 Postgres 유저로 접속 후 유저 생성 sudo -u postgres psql CREATE ROLE replication WITH REPLICATION PASSWORD \u0026#39;password\u0026#39; LOGIN;   /etc/postgresql/9.5/main/postgresql.conf 파일 수정\nwal_level = hot_standby max_wal_senders = 2 max_replication_slots = 2   /etc/postgresql/9.5/main/hba.conf 파일 수정\n아래 문구 추가\nhost all all 192.168.0.138/24 trust host replication replication 192.168.0.138/24 md5 host all all ::1/128 trust   postgresql 재시작\n  STANDBY SERVER 세팅   /etc/postgresql/9.5/main/pg_hba.conf 파일 수정 아래문구 추가\nhost all all 192.168.0.0/24 trust   postgres 유저 추가\n# psql을 Postgres 유저로 접속 후 유저 생성 sudo -u postgres psql CREATE ROLE replication WITH REPLICATION PASSWORD \u0026#39;password\u0026#39; LOGIN;   master server backup 진행\n# 백업 진행하기 전 postgresql 종료 systemctl stop postgresql # 백업은 꼭 postgres 유저로 진행해야 됨 (중요) su postgres # /var/lib/postgresql/9.5/main 아래의 데이터는 데이터 베이스가 동작하는 main 디렉토리 # 하위 데이터가 없어야 백업이 정상적으로 실행됨 rm -rf /var/lib/postgresql/9.5/main/* pg_basebackup -h 192.168.0.123 -D /var/lib/postgresql/9.5/main/ -U replication -P -v -X stream   /var/lib/postgresql/9.5/main/recovery 파일 생성\nstandby_mode=\u0026#39;on\u0026#39; primary_conninfo=\u0026#39;host=192.168.0.123 port=5432 user=replication password=password\u0026#39; primary_slot_name=\u0026#39;repl_slot_01\u0026#39; trigger_file=\u0026#39;/var/lib/postgresql/9.5/main/failover_trigger\u0026#39;   postgresql 실행\nsystemctl start postgresql   replication 실행 확인   master 서버에서의 확인\nselect * from pg_stat_replication; 아래처럼 1 row 가 출력되면 1개의 replication이 돌고 있는 것  /database/postgres-replication-setting/Untitled.png \n  slave 에서의 확인\n/var/log/postgresql/postgresql-9.5-main.log 로그에서 아래와 같이 recovery 로그가 있으면 성공\n /database/postgres-replication-setting/Untitled1.png \n  master / slave 모두 확인\nps -ef | grep post 를 입력했을때 아래와 같이 recovering 이라는 프로세스가 돌고있으면 성공!\n /database/postgres-replication-setting/Untitled2.png \n  혹시 틀린부분 있으면 피드백 부탁드립니다!\n","date":"2020-11-20T16:54:37+09:00","permalink":"https://sung-won95.github.io/p/postgres-replication-%ED%95%98%EB%8A%94%EB%B0%A9%EB%B2%95/","title":"postgres replication 하는방법"}]